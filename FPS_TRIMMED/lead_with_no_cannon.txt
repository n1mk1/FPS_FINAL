#include <GL/freeglut.h>
#include <SOIL.h> // Include SOIL for texture loading
#include <cmath>
#include <unordered_set>
#include <vector>
#define M_PI 3.14

// Structs and Global Variables
struct Bullet {
    float x, y, z;
    float dirX, dirY, dirZ;
};

// Camera position
float cameraX = 0.0f, cameraY = 5.0f, cameraZ = 10.0f;
float cameraAngleH = 0.0f; // Horizontal angle
float cameraAngleV = 0.0f; // Vertical angle (for yaw)
float cameraLeanAngle = 0.0f; // Lean angle for camera tilt

// Jumping mechanics
bool isJumping = false;
float jumpVelocity = 0.2f; // Vertical velocity
const float gravity = -0.003f; // Gravity effect
const float jumpStrength = 0.3f; // Initial jump velocity
const float groundLevel = 5.0f; // Default ground level

// Mouse sensitivity
const float sensitivity = 0.001f;

// Plane dimensions
const int planeSize = 50;

// Key state tracking
std::unordered_set<unsigned char> activeKeys;

// Texture IDs
GLuint planeTexture;
GLuint wallTexture;
GLuint uiTexture;

// Bullet container
std::vector<Bullet> bullets;

// Function Declarations
GLuint loadTexture(const char* fileName);
void drawPlane();
void drawWalls();
void drawBullets();
void drawUIOverlay();
void setCamera();
void display();
void handleMovement();
void fireBullet();
void keyboard(unsigned char key, int x, int y);
void keyboardUp(unsigned char key, int x, int y);
void mouseClick(int button, int state, int x, int y);
void mouseMotion(int x, int y);
void reshape(int w, int h);

// Function Definitions

// Function to load a texture
GLuint loadTexture(const char* fileName) {
    GLuint tex;
    tex = SOIL_load_OGL_texture(
        fileName,
        SOIL_LOAD_AUTO,
        SOIL_CREATE_NEW_ID,
        SOIL_FLAG_MIPMAPS | SOIL_FLAG_INVERT_Y | SOIL_FLAG_TEXTURE_REPEATS
    );

    if (!tex) {
        printf("SOIL loading error: '%s'\n", SOIL_last_result());
    }

    glBindTexture(GL_TEXTURE_2D, tex);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    return tex;
}

// Function to draw a textured plane
void drawPlane() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, planeTexture);

    glColor3f(1.0f, 1.0f, 1.0f); // White to show texture colors
    glBegin(GL_QUADS);

    // Draw a single large quad for the plane with the texture mapped across it
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(planeSize, 0.0f, planeSize);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-planeSize, 0.0f, planeSize);

    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// Function to draw textured walls
void drawWalls() {
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, wallTexture);

    glColor3f(1.0f, 1.0f, 1.0f); // White to show texture colors
    glBegin(GL_QUADS);

    // Front wall
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(planeSize, planeSize, -planeSize);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-planeSize, planeSize, -planeSize);

    // Back wall
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-planeSize, 0.0f, planeSize);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(planeSize, 0.0f, planeSize);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(planeSize, planeSize, planeSize);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-planeSize, planeSize, planeSize);

    // Left wall
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-planeSize, 0.0f, planeSize);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-planeSize, planeSize, planeSize);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-planeSize, planeSize, -planeSize);

    // Right wall
    glTexCoord2f(0.0f, 0.0f); glVertex3f(planeSize, 0.0f, -planeSize);
    glTexCoord2f(1.0f, 0.0f); glVertex3f(planeSize, 0.0f, planeSize);
    glTexCoord2f(1.0f, 1.0f); glVertex3f(planeSize, planeSize, planeSize);
    glTexCoord2f(0.0f, 1.0f); glVertex3f(planeSize, planeSize, -planeSize);

    glEnd();

    glDisable(GL_TEXTURE_2D);
}

// Function to draw bullets
void drawBullets() {
    glColor3f(1.0f, 1.0f, 0.0f); // Yellow color for bullets
    for (const Bullet& bullet : bullets) {
        glPushMatrix();
        glTranslatef(bullet.x, bullet.y + 0.1f, bullet.z);
        glutSolidSphere(0.05f, 16, 16); // Draw bullet as a small sphere
        glPopMatrix();
    }
}

// Function to draw the UI overlay (crosshair)
void drawUIOverlay() {
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    gluOrtho2D(0, 1920, 0, 1080); // Set orthographic projection matching window size

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, uiTexture);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // Enable transparency handling

    glColor3f(1.0f, 1.0f, 1.0f); // Set color to white to display texture properly

    glBegin(GL_QUADS);
    // Coordinates are specified to place the UI at the desired location (center of the screen)
    glTexCoord2f(0.0f, 0.0f); glVertex2f(910.0f, 545.0f);    // Bottom-left corner
    glTexCoord2f(1.0f, 0.0f); glVertex2f(1010.0f, 545.0f);   // Bottom-right corner
    glTexCoord2f(1.0f, 1.0f); glVertex2f(1010.0f, 645.0f);   // Top-right corner
    glTexCoord2f(0.0f, 1.0f); glVertex2f(910.0f, 645.0f);    // Top-left corner
    glEnd();

    glDisable(GL_BLEND);
    glDisable(GL_TEXTURE_2D);

    glMatrixMode(GL_PROJECTION);
    glPopMatrix();

    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
}

// Function to set the camera
void setCamera() {
    float dirX = sin(cameraAngleH) * cos(cameraAngleV);
    float dirY = sin(cameraAngleV);
    float dirZ = -cos(cameraAngleH) * cos(cameraAngleV);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(cameraX, cameraY, cameraZ, cameraX + dirX, cameraY + dirY, cameraZ + dirZ, 0.0f, 1.0f, 0.0f);
    glRotatef(cameraLeanAngle, 0.0f, 0.0f, 1.0f); // Apply lean effect to the camera
}

// Display callback
void display() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    setCamera();

    drawPlane();
    drawWalls();
    drawBullets();

    // Render the 2D UI Overlay
    drawUIOverlay();

    glutSwapBuffers();
}

// Function to handle continuous movement
void handleMovement() {
    const float baseSpeed = 0.15f;
    float speed = baseSpeed;

    // Check if shift key is pressed to double the speed
    if (activeKeys.count('c')) {
        speed *= 2.0f;
    }

    float dirX = sin(cameraAngleH) * cos(cameraAngleV);
    float dirZ = -cos(cameraAngleH) * cos(cameraAngleV);

    if (activeKeys.count('w')) { // Move forward
        cameraX += dirX * speed;
        cameraZ += dirZ * speed;
    }
    if (activeKeys.count('s')) { // Move backward
        cameraX -= dirX * speed;
        cameraZ -= dirZ * speed;
    }
    if (activeKeys.count('a')) { // Strafe left
        cameraX -= cos(cameraAngleH) * speed;
        cameraZ -= sin(cameraAngleH) * speed;
        cameraLeanAngle = -2.0f; // Lean left when strafing left
    }
    else if (activeKeys.count('d')) { // Strafe right
        cameraX += cos(cameraAngleH) * speed;
        cameraZ += sin(cameraAngleH) * speed;
        cameraLeanAngle = 2.0f; // Lean right when strafing right
    }
    else {
        cameraLeanAngle = 0.0f; // Reset lean angle when not strafing
    }

    // Restrict camera movement to stay within walls
    if (cameraX < -planeSize + 2.0f) cameraX = -planeSize + 2.0f;
    if (cameraX > planeSize - 2.0f) cameraX = planeSize - 2.0f;
    if (cameraZ < -planeSize + 2.0f) cameraZ = -planeSize + 2.0f;
    if (cameraZ > planeSize - 2.0f) cameraZ = planeSize - 2.0f;

    // Jump mechanics
    if (isJumping) {
        cameraY += jumpVelocity;
        jumpVelocity += gravity;

        if (cameraY <= groundLevel) { // Land back on the ground
            cameraY = groundLevel;
            isJumping = false;
            jumpVelocity = 0.0f;
        }
    }

    // Update bullet positions
    for (Bullet& bullet : bullets) {
        bullet.x += bullet.dirX * 0.5f;
        bullet.y += bullet.dirY * 0.5f;
        bullet.z += bullet.dirZ * 0.5f;
    }

    glutPostRedisplay();
}

// Function to fire a bullet
void fireBullet() {
    float dirX = sin(cameraAngleH) * cos(cameraAngleV);
    float dirY = sin(cameraAngleV);
    float dirZ = -cos(cameraAngleH) * cos(cameraAngleV);

    Bullet bullet = { cameraX, cameraY, cameraZ, dirX, dirY, dirZ };
    bullets.push_back(bullet);
}

// Key press callback
void keyboard(unsigned char key, int x, int y) {
    activeKeys.insert(key);

    if (key == ' ' && !isJumping) { // Jump on space key if not already jumping
        isJumping = true;
        jumpVelocity = jumpStrength;
    }
    if (key == 'f') { // Fire bullet when 'f' key is pressed
        fireBullet();
    }
}

// Key release callback
void keyboardUp(unsigned char key, int x, int y) {
    activeKeys.erase(key);
}

// Mouse click callback
void mouseClick(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        fireBullet();
    }
}

// Mouse movement callback with infinite movement support
void mouseMotion(int x, int y) {
    static const int centerX = 400; // Center X position (half of window width)
    static const int centerY = 300; // Center Y position (half of window height)
    static bool justWarped = false;

    // Ignore the mouse event triggered by the warp itself
    if (justWarped) {
        justWarped = false;
        return;
    }

    // Calculate delta movement
    int dx = x - centerX;
    int dy = y - centerY;

    // Update camera angles based on delta movement
    cameraAngleH += dx * sensitivity;
    cameraAngleV -= dy * sensitivity;

    // Clamp the vertical angle to -90 to +90 degrees
    if (cameraAngleV > 1.57f) // ~90 degrees in radians
        cameraAngleV = 1.57f;
    if (cameraAngleV < -1.57f)
        cameraAngleV = -1.57f;

    // Warp the mouse back to the center of the screen
    glutWarpPointer(centerX, centerY);
    justWarped = true;

    glutPostRedisplay();
}

// Reshape callback
void reshape(int w, int h) {
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (double)w / (double)h, 1.0, 100.0);
}

// Update in the main function
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(1920, 1080);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("Walkable Flat Plane with Texture and Jump");

    glEnable(GL_DEPTH_TEST);

    // Load textures
    planeTexture = loadTexture("land.jpg");
    wallTexture = loadTexture("wall.jpg");
    uiTexture = loadTexture("crosshair.png");

    // Center the cursor at the beginning
    glutWarpPointer(400, 300);
    glutSetCursor(GLUT_CURSOR_NONE); // Hide the cursor for better FPS experience

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutKeyboardUpFunc(keyboardUp); // Key release callback
    glutMouseFunc(mouseClick); // Mouse click callback
    glutMotionFunc(mouseMotion); // Mouse movement callback with left-click pressed
    glutPassiveMotionFunc(mouseMotion); // Mouse movement callback without button pressed
    glutIdleFunc(handleMovement); // Handle movement continuously

    glutMainLoop();
    return 0;
}
